### Report for OSH-Lab3

#### Xu-Yuanyuan  PB20511899  2022/6/1

------

**Note**：对所有文件都做了对话测试以及传`lab1`的`bzImage`的测试，并用`diff`命令比较无误。

- 实现功能：（14分）

  - 双人聊天室 2’ + 2‘

    - 实现以换行为分隔符的消息分割 2'

      每次recv最多接受到1048600个字节，存到buffer中。一次recv后，buffer中至少有一个`\n`（因为和助教确认的是每两个`\n`之间最多1MB的消息）。检测buffer中`\n`的位置，并将其在`\n`处分割。不断的将buffer中开头到第一个`\n`的内容或者是两`\n`之间的内容进行`strncpy`**接续**到预设的消息字符串msg中，并进行send，余下的部分（即到buffer的末尾也没有遇到`\n`的部分）会拷贝进`message`的开头，等待并续上下一次`recv`接受到的信息，直至检测到`\n`，续到后面进行`send`（由此可见为什么上面选择的是接续式的拷贝）。

    - 处理 `send` 无法一次发送所有数据的情况 2'

      设置剩余要发送信息的长度`remain`和已发送信息的长度`sended`，用 `send` 的返回值更新这两个数据，即：`remain = remain - sended`，当`remain > 0`时，说明没发完，将要发送的信息初始地址加上sended，再接续继续发送，重复上述的检测过程。

  - 简单的多线程聊天室 4' + 2‘

    - 细粒度锁 2'

      - 简言之：多个消息队列并行`send`，锁上在消息队列**出入队**操作上。

      - 每个线程（一位用户）拥有一个独立的接受信息队列，共计32个消息队列和32个`mutex`。当一个线程要发生信息时，会循环将32个 `mutex` 分别锁住，进行**入队操作**输入msg和目标用户信息，入队操作之后将`mutex`进行`unlock`。所有的客户端接受消息均各有一个线程，会不断对队列进行判空，如果队列非空则请求锁住`mutex`，出队操作后将`mutex`进行unlock，而后根据出队得到的信息进行send操作。
      
      - 我的队列是结构体数组循环队列，每次Enqueue和Dequeue都是以结构体元素进行操作的。然后每个消息队列的长度都是32（最大长度31），实际测试发送几MB的文件给多方时未出现溢出导致入队失败从而信息丢失的情况，但不排除其可能存在。能做到以下的操作：
      
        1. 如果有哪个用户端的send操作失败或是出现问题，只会影响这一个客户端，其他客户端仍可正常运转；
      
        2. 我的实现是只有一个线程循环`revc`并给各个用户入队，而发射端是至多32个线程一一对应地向各用户发送信息，所以我想其速度应该要低于发射端，因此可能会存在发射线程不断判队空（类似于轮询直到有信息），相当于会有一段等待时间，但不会造成问题，并且此时是因为并行发射效率高而使得等待时间的出现。
      
      - 用户退出时，线程能检测到用户退出，将该用户的套接字关闭，线程退出，释放资源。
  
  - 基于 IO 复用/异步 IO 的多人聊天室 4’
  
    - SELECT 4'
  
      使用 `select` 返回时：
      
      - 如果是有新的连接，使用`accept`；
      
      - 如果是有用户退出，处理同多线程；
      
      - 如果是找到了可接收的套接字，进入消息的处理；
      
        > 用先前实现的发送方式完成向其他所有客户端`send`之后，当确认到`recv`的返回值为0时，才等待下一次`select`。

